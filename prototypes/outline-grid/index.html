<!DOCTYPE html>
<html lang="de">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" href="data:,">
	<style>
		svg {
			border: 1px dashed black;
		}
	</style>
	<script type="module">
		function createCircle(point, color) {
			const e = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
			e.setAttribute('cx', point.x);
			e.setAttribute('cy', point.y);
			e.setAttribute('r', 2);
			e.setAttribute('style', 'fill:' + color);
			return e;
		}

		function createLine(point1, point2, color) {
			const e = document.createElementNS('http://www.w3.org/2000/svg', 'line');
			e.setAttribute('x1', point1.x);
			e.setAttribute('y1', point1.y);
			e.setAttribute('x2', point2.x);
			e.setAttribute('y2', point2.y);
			e.setAttribute('style', 'stroke:' + color);
			return e;
		}

		function createQuadraticBezier(point1, point2, point3, color) {
			const e = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			e.setAttribute('d', `M${point1.x} ${point1.y} Q${point2.x} ${point2.y},${point3.x} ${point3.y}`);
			e.setAttribute('style', 'fill:none;stroke:' + color);
			return e;
		}

		function middle(a, b) {
			return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
		}

		function distance(a, b) {
			const dx = a.x - b.x;
			const dy = a.y - b.y;
			return Math.sqrt(dx ** 2 + dy ** 2);
		}

		function drawGrid(svg, gridSize) {
			for (let y = 0; y <= HEIGHT; y += gridSize) {
				svg.appendChild(createLine({ x: 0, y: y }, { x: WIDTH, y: y }, '#999'));
			}
			for (let x = 0; x <= WIDTH; x += gridSize) {
				svg.appendChild(createLine({ x: x, y: 0 }, { x: x, y: HEIGHT }, '#999'));
			}
		}

		// https://github.com/Cyan4973/xxHash
		function xxHash32(input, seed = 0) {
			function rotl(x, rotate) {
				return (x << rotate) | (x >>> (32 - rotate));
			}

			function round(acc, input) {
				acc += Math.imul(input, prime2);
				acc = rotl(acc, 13);
				acc = Math.imul(acc, prime1);
				return acc;
			}

			const prime1 = 0x9e3779b1;
			const prime2 = 0x85ebca77;
			const prime3 = 0xc2b2ae3d;
			const prime4 = 0x27d4eb2f;
			const prime5 = 0x165667b1;

			let v1 = (seed + prime1 + prime2) >>> 0;
			let v2 = (seed + prime2) >>> 0;
			let v3 = (seed + 0) >>> 0;
			let v4 = (seed - prime1) >>> 0;

			let hash = 0;

			if (input.length >= 4) {
				for (let i = 0; i < (input.length - 3); i += 4) {
					v1 = round(v1, input[i + 0]);
					v2 = round(v2, input[i + 1]);
					v3 = round(v3, input[i + 2]);
					v4 = round(v4, input[i + 3]);
				}
				hash = rotl(v1, 1) + rotl(v2, 7) + rotl(v3, 12) + rotl(v4, 18);
			} else {
				hash = seed + prime5;
			}

			hash += input.length * 4;

			// finalize

			const rest = input.length - (input.length % 4);
			for (let i = rest; i < input.length; i += 1) {
				hash += Math.imul(input[i], prime3);
				hash = Math.imul(rotl(hash, 17), prime4);
			}

			// avalanche

			hash ^= hash >>> 15;
			hash = Math.imul(hash, prime2);
			hash ^= hash >>> 13;
			hash = Math.imul(hash, prime3);
			hash ^= hash >>> 16;

			return hash >>> 0;
		}

		function float2uint32(floats) {
			const float32Array = new Float32Array(floats);
			const uint32Array = new Uint32Array(float32Array.buffer);
			return Array.from(uint32Array)
		}

		function unitVector(randomNormalized) {
			const angle = randomNormalized * 2 * Math.PI;
			return { x: Math.cos(angle), y: Math.sin(angle) };
		}

		// https://en.wikipedia.org/wiki/Smoothstep
		// 0 <= x <= 1
		function smootherstep(x) {
			return 6 * (x ** 5) - 15 * (x ** 4) + 10 * (x ** 3);
		}

		// https://en.wikipedia.org/wiki/Linear_interpolation
		function lerp(a, b, x) {
			return a + x * (b - a);
		}

		function gridMake(width, height, callable) {
			const data = [];
			for (let y = 0; y < height; y += 1) {
				const row = [];
				for (let x = 0; x < width; x += 1) {
					const v = callable({ x: x, y: y });
					row.push(v);
				}
				data.push(row);
			}
			return { width: width, height: height, data: data };
		}

		function gridForEach(grid, border, callable) {
			for (let y = border; y < (grid.height - border); y += 1) {
				for (let x = border; x < (grid.width - border); x += 1) {
					callable(grid, { x: x, y: y });
				}
			}
		}

		// rnh = Random Number Hash

		function rnhNorm(seeds) {
			//const result = Math.random();
			const result = xxHash32(float2uint32(seeds), 0) / UINT32_MAX;
			console.assert((result >= 0.0) && (result <= 1.0));
			return result;
		}

		function rnhMinMax(seeds, min, max) {
			const r = rnhNorm(seeds);
			return min + (r * (max - min));
		}

		function perlinCreate(seed, width, height) {
			return gridMake(width, height, p => unitVector(rnhNorm([seed, p.x, p.y])));
		}

		function perlinNoise(perlin, coord) {
			function interpolate(a, b, x) {
				return a + smootherstep(x) * (b - a);
			}

			function dot(p, pf) {
				const gradient = perlin.data[pf.y][pf.x];
				const v = { x: p.x - pf.x, y: p.y - pf.y };
				return v.x * gradient.x + v.y * gradient.y;
			}

			const xf = Math.floor(coord.x);
			const yf = Math.floor(coord.y);
			const tl = dot(coord, { x: xf + 0, y: yf + 0 });
			const tr = dot(coord, { x: xf + 1, y: yf + 0 });
			const bl = dot(coord, { x: xf + 0, y: yf + 1 });
			const br = dot(coord, { x: xf + 1, y: yf + 1 });
			const t = interpolate(tl, tr, coord.x - xf);
			const b = interpolate(bl, br, coord.x - xf);
			const v = interpolate(t, b, coord.y - yf);
			return v;
		}

		// h = 0..360, s = 0..100, l = 0..100
		function hslString(h, s, l) {
			return 'hsl(' + h + ',' + s + '%,' + l + '%)';
		}

		async function loadSVG(filename) {
			const response = await fetch(filename);
			const text = await response.text();
			const svg = (new DOMParser()).parseFromString(text, 'image/svg+xml');
			return svg.children[0].children[2];
		}

		const UINT32_MAX = 0xffffffff;

		function isUint32(x) {
			return Number.isInteger(x) && (x >= 0) && (x <= UINT32_MAX);
		}

		// rng = Random Number Generator

		// https://de.wikipedia.org/wiki/Xorshift
		// XORShift128
		function rngCreate(seed) {
			console.assert(isUint32(seed));
			// return { x: 123456789, y: 362436069, z: 521288629, w: 88675123 };
			// TODO possible initial states maybe limited too much? run a few first rounds?
			return { x: seed, y: 0, z: 0, w: 0 };
		}

		function rngNext(state) {
			const t = state.x ^ (state.x << 11);
			const result = {
				x: state.y,
				y: state.z,
				z: state.w,
				w: (state.w ^ ((state.w >>> 19) ^ t ^ (t >>> 8))) >>> 0
			};
			console.assert((result.w >= 0) && (result.w <= UINT32_MAX));
			return result;
		}

		const WIDTH = 1000;
		const HEIGHT = 800;
		const GRID_SIZE = 25;

		async function main() {
			const svg = document.getElementById('svg');
			svg.setAttribute('width', WIDTH);
			svg.setAttribute('height', HEIGHT);

			// https://www.freepik.com/free-vector/vintage-monochrome-mountains-set_7997411.htm
			const names = ['mountain1.svg', 'mountain2.svg', 'mountain3.svg'];
			const mountains = await Promise.all(names.map($ => loadSVG($)));

			// this would is the only user controlled number
			const seed = 0.3; // Math.random();

			const seedRandom = 0.7;
			const seedX = 0.9;
			const seedY = 0.8;

			const perlin = perlinCreate(seed, 10 + 2, 8 + 2);

			const gridBorderMin = 0.2;
			const gridBorderMax = 0.8;

			const w = Math.floor(WIDTH / GRID_SIZE);
			const h = Math.floor(HEIGHT / GRID_SIZE);
			// TOOD use gridForEach for init?
			const g = gridMake(w, h, (p) => {
				const xn = p.x / w;
				const yn = p.y / h;
				return {
					random: rnhNorm([seed, seedRandom, xn, yn]), // used in many places
					x: (rnhMinMax([seed, seedX, xn, yn], gridBorderMin, gridBorderMax) + p.x) * GRID_SIZE,
					y: (rnhMinMax([seed, seedY, xn, yn], gridBorderMin, gridBorderMax) + p.y) * GRID_SIZE
				};
			});

			drawGrid(svg, GRID_SIZE);

			function selectBiome(p) {
				if (p.level > 1.4) return 'mountain';
				if (p.level > 1.0 && p.random < 0.02) return 'town';
				if (p.level > 0.8) return 'grass';
				return 'water';
			}

			const towns = [];
			// assign level & biomes
			gridForEach(g, 0, (grid, tile) => {
				const p = grid.data[tile.y][tile.x];
				let noise = perlinNoise(perlin, { x: p.x / 200, y: p.y / 200 });
				p.level = noise + 1.0; // 0 .. 2
				p.biome = selectBiome(p);
				if (p.biome === 'town') {
					towns.push({ x: p.x, y: p.y });
				}
			});


			// streets
			const SHOW_STREETS = true;
			if (SHOW_STREETS) {
				for (const from of towns) {
					const toList = towns.
						filter(to => (from.x != to.x) || (from.y != to.y)).
						map(to => ({ x: to.x, y: to.y, distance: distance(from, to) }));
					// only search the closest town
					if (toList.length > 0) {
						toList.sort((a, b) => a.distance > b.distance ? 1 : -1);
						svg.appendChild(createLine(from, toList[0], '#999'));
					}
				}
			}

			// biomes
			const BIOMES_COLORS = {
				'town': '#f0f',
				'water': '#00f',
				'grass': '#9f9',
				'mountain': '#999',
			};
			const SHOW_BIOMES = true;
			if (SHOW_BIOMES) {
				gridForEach(g, 0, (grid, tile) => {
					const p = grid.data[tile.y][tile.x];
					svg.appendChild(createCircle(p, BIOMES_COLORS[p.biome]));
				});
			}

			// mountains
			const items = [];
			gridForEach(g, 0, (grid, tile) => {
				const p = grid.data[tile.y][tile.x];
				if (p.biome === 'mountain') {
					// TODO maybe do not use the same seed for everything
					const m = mountains[Math.floor(p.random * mountains.length)];
					const node = m.cloneNode(true);
					const xScale = 1.1 + (p.random * 0.2);
					const yScale = 1.3 + (p.random * 0.2);
					const x = p.x;
					const y = p.y;
					items.push({ x: x, y: y, xs: xScale, ys: yScale, node });
				}
			});

			items.sort((a, b) => {
				return (a.y > b.y) ? 1 : -1;
			});

			const SHOW_ITEMS = true;
			if (SHOW_ITEMS) {
				for (const item of items) {
					const node = item.node;
					node.setAttribute('transform', 'translate(' + item.x + ' ' + item.y + ') scale(' + item.xs + ' ' + item.ys + ')')
					svg.appendChild(node);
				}
			}

			// draw coast
			gridForEach(g, 1, (grid, tile) => {
				const p = grid.data[tile.y][tile.x];
				const pl = grid.data[tile.y + 0][tile.x - 1];
				const pr = grid.data[tile.y + 0][tile.x + 1];
				const pt = grid.data[tile.y - 1][tile.x - 0];
				const pb = grid.data[tile.y + 1][tile.x + 0];
				const ptl = grid.data[tile.y - 1][tile.x - 1];
				const ptr = grid.data[tile.y - 1][tile.x + 1];
				const pbl = grid.data[tile.y + 1][tile.x - 1];
				const pbr = grid.data[tile.y + 1][tile.x + 1];
				let ps = [];

				// tr
				if (p.biome === 'water' && pt.biome == 'water' && ptr.biome == 'water' && pr.biome == 'grass') {
					ps.push(ptr);
				}
				if (p.biome === 'water' && pt.biome == 'water' && ptr.biome == 'grass' && pr.biome == 'grass') {
					ps.push(pt);
				}
				if (p.biome === 'water' && pt.biome == 'grass' && ptr.biome == 'grass' && pr.biome == 'water') {
					ps.push(pr);
				}
				if (p.biome === 'water' && pt.biome == 'grass' && ptr.biome == 'water' && pr.biome == 'water') {
					ps.push(ptr);
				}
				// br
				if (p.biome === 'water' && pb.biome == 'water' && pbr.biome == 'water' && pr.biome == 'grass') {
					ps.push(pbr);
				}
				if (p.biome === 'water' && pb.biome == 'water' && pbr.biome == 'grass' && pr.biome == 'grass') {
					ps.push(pb);
				}
				if (p.biome === 'water' && pb.biome == 'grass' && pbr.biome == 'water' && pr.biome == 'water') {
					ps.push(pbr);
				}
				if (p.biome === 'water' && pb.biome == 'grass' && pbr.biome == 'grass' && pr.biome == 'water') {
					ps.push(pr);
				}
				// bl
				if (p.biome === 'water' && pb.biome == 'water' && pbl.biome == 'water' && pl.biome == 'grass') {
					ps.push(pbl);
				}
				if (p.biome === 'water' && pb.biome == 'water' && pbl.biome == 'grass' && pl.biome == 'grass') {
					ps.push(pb);
				}
				if (p.biome === 'water' && pb.biome == 'grass' && pbl.biome == 'water' && pl.biome == 'water') {
					ps.push(pbl);
				}
				if (p.biome === 'water' && pb.biome == 'grass' && pbl.biome == 'grass' && pl.biome == 'water') {
					ps.push(pl);
				}
				// tl
				if (p.biome === 'water' && pt.biome == 'water' && ptl.biome == 'water' && pl.biome == 'grass') {
					ps.push(ptl);
				}
				if (p.biome === 'water' && pt.biome == 'water' && ptl.biome == 'grass' && pl.biome == 'grass') {
					ps.push(pt);
				}
				if (p.biome === 'water' && pt.biome == 'grass' && ptl.biome == 'water' && pl.biome == 'water') {
					ps.push(ptl);
				}
				if (p.biome === 'water' && pt.biome == 'grass' && ptl.biome == 'grass' && pl.biome == 'water') {
					ps.push(pl);
				}

				if (ps.length == 2) {
					svg.appendChild(createQuadraticBezier(middle(p, ps[0]), p, middle(p, ps[1]), '#00f'));
				} else if (ps.length == 4) {
					// other combinations 0213 may also work
					svg.appendChild(createQuadraticBezier(middle(p, ps[0]), p, middle(p, ps[1]), '#00f'));
					svg.appendChild(createQuadraticBezier(middle(p, ps[2]), p, middle(p, ps[3]), '#00f'));
				}
			});
		}

		document.addEventListener('DOMContentLoaded', main);
		//setTimeout(main, 400);
	</script>

<body>
	<object id="mountain1" type="image/svg+xml" data="mountain1.svg" style="display:none"></object>
	<svg id="svg"></svg>
</body>

</html>