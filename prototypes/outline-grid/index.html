<!DOCTYPE html>
<html lang="de">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		svg {
			border: 1px dashed black;
		}
	</style>
	<script type="module">
		function createCircle(point, color) {
			const e = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
			e.setAttribute('cx', point.x);
			e.setAttribute('cy', point.y);
			e.setAttribute('r', 2);
			e.setAttribute('style', 'fill:' + color);
			return e;
		}

		function createLine(point1, point2, color) {
			const e = document.createElementNS('http://www.w3.org/2000/svg', 'line');
			e.setAttribute('x1', point1.x);
			e.setAttribute('y1', point1.y);
			e.setAttribute('x2', point2.x);
			e.setAttribute('y2', point2.y);
			e.setAttribute('style', 'stroke:' + color);
			return e;
		}

		function createQuadraticBezier(point1, point2, point3, color) {
			const e = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			e.setAttribute('d', `M${point1.x} ${point1.y} Q${point2.x} ${point2.y},${point3.x} ${point3.y}`);
			e.setAttribute('style', 'fill:none;stroke:' + color);
			return e;
		}

		function lineCenter(point1, point2) {
			return { x: (point1.x + point2.y) / 2, y: (point1.y + point2.y) / 2 };
		}

		function drawGrid(svg, gridSize) {
			for (let y = 0; y <= HEIGHT; y += gridSize) {
				svg.appendChild(createLine({ x: 0, y: y }, { x: WIDTH, y: y }, '#999'));
			}
			for (let x = 0; x <= WIDTH; x += gridSize) {
				svg.appendChild(createLine({ x: x, y: 0 }, { x: x, y: HEIGHT }, '#999'));
			}
		}

		function randomMinMax(min, max) {
			return min + (Math.random() * (max - min));
		}

		function randomInt(max) {
			return Math.floor(Math.random() * max);
		}

		function randomUnitVector() {
			const angle = Math.random() * 2 * Math.PI;
			return { x: Math.cos(angle), y: Math.sin(angle) };
		}

		// https://en.wikipedia.org/wiki/Smoothstep
		// 0 <= x <= 1
		function smootherstep(x) {
			return 6 * (x ** 5) - 15 * (x ** 4) + 10 * (x ** 3);
		}

		// https://en.wikipedia.org/wiki/Linear_interpolation
		function lerp(a, b, x) {
			return a + x * (b - a);
		}

		function gridMake(width, height, callable) {
			const data = [];
			for (let y = 0; y < height; y += 1) {
				const row = [];
				for (let x = 0; x < width; x += 1) {
					const v = callable({ x: x, y: y });
					row.push(v);
				}
				data.push(row);
			}
			return { width: width, height: height, data: data };
		}

		function gridForEach(grid, border, callable) {
			for (let y = border; y < (grid.height - border); y += 1) {
				for (let x = border; x < (grid.width - border); x += 1) {
					callable(grid, { x: x, y: y });
				}
			}
		}

		function perlinCreate(width, height) {
			return { gradients: gridMake(width, height, () => randomUnitVector()) };
		}

		function perlinNoise(perlin, coord) {
			function interpolate(a, b, x) {
				return a + smootherstep(x) * (b - a);
			}

			function dot(p, pf) {
				const gradient = perlin.gradients.data[pf.y][pf.x];
				const v = { x: p.x - pf.x, y: p.y - pf.y };
				return v.x * gradient.x + v.y * gradient.y;
			}

			const xf = Math.floor(coord.x);
			const yf = Math.floor(coord.y);
			const tl = dot(coord, { x: xf + 0, y: yf + 0 });
			const tr = dot(coord, { x: xf + 1, y: yf + 0 });
			const bl = dot(coord, { x: xf + 0, y: yf + 1 });
			const br = dot(coord, { x: xf + 1, y: yf + 1 });
			const t = interpolate(tl, tr, coord.x - xf);
			const b = interpolate(bl, br, coord.x - xf);
			const v = interpolate(t, b, coord.y - yf);
			return v;
		}

		const WIDTH = 1000;
		const HEIGHT = 500;
		const GRID_SIZE = 30;

		// h = 0..360, s = 0..100, l = 0..100
		function hslString(h, s, l) {
			return 'hsl(' + h + ',' + s + '%,' + l + '%)';
		}

		async function loadsvg(filename) {
			const response = await fetch(filename);
			const text = await response.text();
			const svg = (new DOMParser()).parseFromString(text, 'image/svg+xml');
			return svg.children[0].children[2];
		}

		async function main() {
			const svg = document.getElementById('svg');
			svg.setAttribute('width', WIDTH);
			svg.setAttribute('height', HEIGHT);

			const names = ['mountain1.svg', 'mountain2.svg', 'mountain3.svg'];
			const mountains = await Promise.all(names.map($ => loadsvg($)));

			const perlin = perlinCreate(10 + 2, 8 + 2);

			const gridBorderMin = 0.2;
			const gridBorderMax = 0.8;
			const g = gridMake(Math.floor(WIDTH / GRID_SIZE), Math.floor(HEIGHT / GRID_SIZE), (p) => {
				return {
					x: (randomMinMax(gridBorderMin, gridBorderMax) + p.x) * GRID_SIZE,
					y: (randomMinMax(gridBorderMin, gridBorderMax) + p.y) * GRID_SIZE
				};
			});

			drawGrid(svg, GRID_SIZE);

			function biomeFromLevel(level) {
				if (level > 1.4) return 'mountain';
				if (level > 1.0 && Math.random() < 0.02) return 'town';
				if (level > 0.8) return 'grass';
				return 'water';
			}

			const towns = [];
			// assign level & biomes
			gridForEach(g, 0, (grid, tile) => {
				const p = grid.data[tile.y][tile.x];
				let noise = perlinNoise(perlin, { x: p.x / 200, y: p.y / 200 });
				p.level = noise + 1.0; // 0 .. 2
				p.biome = biomeFromLevel(p.level);
				if (p.biome === 'town') {
					towns.push({ x: p.x, y: p.y });
				}
			});

			function distance(a, b) {
				const dx = a.x - b.x;
				const dy = a.y - b.y;
				return Math.sqrt(dx ** 2 + dy ** 2);
			}

			// streets
			// only search the closes city
			for (const from of towns) {
				const toList = [];
				for (const to of towns) {
					if ((from.x !== to.x) || (from.y !== to.y)) {
						toList.push({ x: to.x, y: to.y, distance: distance(from, to) });
					}
				}
				toList.sort((a, b) => {
					return a.distance > b.distance ? 1 : -1;
				});
				svg.appendChild(createLine(from, toList[0], '#999'));
			}

			// color tile
			const BIOME_COLORS = {
				'town': '#f0f',
				'water': '#00f',
				'grass': '#9f9',
				'mountain': '#999',
			};
			gridForEach(g, 0, (grid, tile) => {
				const p = grid.data[tile.y][tile.x];
				svg.appendChild(createCircle(p, BIOME_COLORS[p.biome]));
			});

			// mountains
			const items = [];
			gridForEach(g, 0, (grid, tile) => {
				const p = grid.data[tile.y][tile.x];
				if (p.biome === 'mountain') {
					const m = mountains[randomInt(mountains.length)];
					const node = m.cloneNode(true);
					const xScale = 1.1 + (Math.random() * 0.2);
					const yScale = 1.3 + (Math.random() * 0.2);
					const x = p.x;
					const y = p.y;
					items.push({ x: x, y: y, xs: xScale, ys: yScale, node });
				}
			});

			items.sort((a, b) => {
				return (a.y > b.y) ? 1 : -1;
			});

			for (const item of items) {
				const node = item.node;
				node.setAttribute('transform', 'translate(' + item.x + ' ' + item.y + ') scale(' + item.xs + ' ' + item.ys + ')')
				svg.appendChild(node);
			}

			// draw coast
			gridForEach(g, 1, (grid, tile) => {
				const p = grid.data[tile.y][tile.x];
				const pr = grid.data[tile.y + 0][tile.x + 1];
				const pb = grid.data[tile.y + 1][tile.x + 0];
				const pbr = grid.data[tile.y + 1][tile.x + 1];
				if (p.biome === 'water' && pr.biome === 'water' && pb.biome === 'grass' && pbr.biome === 'grass') {
					svg.appendChild(createLine(p, pr, 'blue'));
					//svg.appendChild(createQuadraticBezier(p, pr, pr, 'water'));
				}
				if (p.biome === 'water' && pr.biome === 'water' && pb.biome === 'grass' && pbr.biome === 'water') {
					svg.appendChild(createLine(p, pbr, 'blue'));
					//svg.appendChild(createQuadraticBezier(p, pr, pbr, 'water'));
				}
				if (p.biome === 'grass' && pr.biome === 'water' && pb.biome === 'grass' && pbr.biome === 'water') {
					svg.appendChild(createLine(pr, pbr, 'blue'));
				}
				if (p.biome === 'water' && pr.biome === 'water' && pb.biome === 'water' && pbr.biome === 'grass') {
					svg.appendChild(createLine(pb, pr, 'blue'));
				}
				if (p.biome === 'water' && pr.biome === 'grass' && pb.biome === 'water' && pbr.biome === 'grass') {
					svg.appendChild(createLine(p, pb, 'blue'));
				}
				if (p.biome === 'grass' && pr.biome === 'grass' && pb.biome === 'water' && pbr.biome === 'water') {
					svg.appendChild(createLine(pb, pbr, 'blue'));
				}
				if (p.biome === 'water' && pr.biome === 'grass' && pb.biome === 'water' && pbr.biome === 'water') {
					svg.appendChild(createLine(p, pbr, 'blue'));
				}
				if (p.biome === 'grass' && pr.biome === 'water' && pb.biome === 'water' && pbr.biome === 'water') {
					svg.appendChild(createLine(pb, pr, 'blue'));
					//svg.appendChild(createQuadraticBezier(pb, pbr, pr, 'water'));
				}
			});

		}

		document.addEventListener('DOMContentLoaded', main);
		//setTimeout(main, 400);
	</script>

<body>
	<object id="mountain1" type="image/svg+xml" data="mountain1.svg" style="display:none"></object>
	<svg id="svg"></svg>
</body>

</html>