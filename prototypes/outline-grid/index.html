<!DOCTYPE html>
<html lang="de">

<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<style>
		svg {
			border: 1px dashed black;
		}
	</style>
	<script type="module">
		function createCircle(point, color) {
			const e = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
			e.setAttribute('cx', point.x);
			e.setAttribute('cy', point.y);
			e.setAttribute('r', 2);
			e.setAttribute('style', 'fill:' + color);
			return e;
		}

		function createLine(point1, point2, color) {
			const e = document.createElementNS('http://www.w3.org/2000/svg', 'line');
			e.setAttribute('x1', point1.x);
			e.setAttribute('y1', point1.y);
			e.setAttribute('x2', point2.x);
			e.setAttribute('y2', point2.y);
			e.setAttribute('style', 'stroke:' + color);
			return e;
		}

		function createQuadraticBezier(point1, point2, point3, color) {
			const e = document.createElementNS('http://www.w3.org/2000/svg', 'path');
			e.setAttribute('d', `M${point1.x} ${point1.y} Q${point2.x} ${point2.y},${point3.x} ${point3.y}`);
			e.setAttribute('style', 'fill:none;stroke:' + color);
			return e;
		}

		function middle(a, b) {
			return { x: (a.x + b.x) / 2, y: (a.y + b.y) / 2 };
		}

		function distance(a, b) {
			const dx = a.x - b.x;
			const dy = a.y - b.y;
			return Math.sqrt(dx ** 2 + dy ** 2);
		}

		function drawGrid(svg, gridSize) {
			for (let y = 0; y <= HEIGHT; y += gridSize) {
				svg.appendChild(createLine({ x: 0, y: y }, { x: WIDTH, y: y }, '#999'));
			}
			for (let x = 0; x <= WIDTH; x += gridSize) {
				svg.appendChild(createLine({ x: x, y: 0 }, { x: x, y: HEIGHT }, '#999'));
			}
		}

		function unitVector(randomNormalized) {
			const angle = randomNormalized * 2 * Math.PI;
			return { x: Math.cos(angle), y: Math.sin(angle) };
		}

		// https://en.wikipedia.org/wiki/Smoothstep
		// 0 <= x <= 1
		function smootherstep(x) {
			return 6 * (x ** 5) - 15 * (x ** 4) + 10 * (x ** 3);
		}

		// https://en.wikipedia.org/wiki/Linear_interpolation
		function lerp(a, b, x) {
			return a + x * (b - a);
		}

		function gridMake(width, height, callable) {
			const data = [];
			for (let y = 0; y < height; y += 1) {
				const row = [];
				for (let x = 0; x < width; x += 1) {
					const v = callable({ x: x, y: y });
					row.push(v);
				}
				data.push(row);
			}
			return { width: width, height: height, data: data };
		}

		function gridForEach(grid, border, callable) {
			for (let y = border; y < (grid.height - border); y += 1) {
				for (let x = border; x < (grid.width - border); x += 1) {
					callable(grid, { x: x, y: y });
				}
			}
		}

		// rnh = Random Number Hash

		// TODO this is not good enough, patterns are easily visible if loop is one
		function rnhNorm3(...params) {
			const sum = params.reduce((acc, $) => acc + $, 0.0);
			const seed = sum / params.length;
			let s = rngCreate(seed);
			for (let i = 0; i < 30; i += 1) {
				s = rngNext(s);
			}
			return s.w / UINT32_MAX;
		}

		// TODO also not good
		function rnhNorm2(...params) {
			const s = params.map($ => $.toString()).join('');
			let hash = 0;
			for (let i = 0; i < s.length; i++) {
				hash = (hash << 5) - hash + s.charCodeAt(i);
			}
			const result = (hash >>> 0) / UINT32_MAX;
			return result;
		}

		// TODO use a proper hash function not random
		function rnhNorm(...params) {
			//const result = rnhNorm2(...params);
			const result = Math.random();
			console.assert((result >= 0.0) && (result <= 1.0));
			return result;
		}

		function rnhMinMax(min, max, ...params) {
			const r = rnhNorm(...params);
			return min + (r * (max - min));
		}

		function perlinCreate(seed, width, height) {
			return gridMake(width, height, p => unitVector(rnhNorm(seed, p.x, p.y)));
		}

		function perlinNoise(perlin, coord) {
			function interpolate(a, b, x) {
				return a + smootherstep(x) * (b - a);
			}

			function dot(p, pf) {
				const gradient = perlin.data[pf.y][pf.x];
				const v = { x: p.x - pf.x, y: p.y - pf.y };
				return v.x * gradient.x + v.y * gradient.y;
			}

			const xf = Math.floor(coord.x);
			const yf = Math.floor(coord.y);
			const tl = dot(coord, { x: xf + 0, y: yf + 0 });
			const tr = dot(coord, { x: xf + 1, y: yf + 0 });
			const bl = dot(coord, { x: xf + 0, y: yf + 1 });
			const br = dot(coord, { x: xf + 1, y: yf + 1 });
			const t = interpolate(tl, tr, coord.x - xf);
			const b = interpolate(bl, br, coord.x - xf);
			const v = interpolate(t, b, coord.y - yf);
			return v;
		}

		// h = 0..360, s = 0..100, l = 0..100
		function hslString(h, s, l) {
			return 'hsl(' + h + ',' + s + '%,' + l + '%)';
		}

		async function loadSVG(filename) {
			const response = await fetch(filename);
			const text = await response.text();
			const svg = (new DOMParser()).parseFromString(text, 'image/svg+xml');
			return svg.children[0].children[2];
		}

		const UINT32_MAX = 2 ** 32;

		function wrapUInt32(x) {
			return x >>> 0;
		}

		// rng = Random Number Generator

		// https://de.wikipedia.org/wiki/Xorshift
		// XORShift128
		function rngCreate(seed) {
			console.assert((seed >= 0.0) && (seed <= 1.0));
			// return { x: 123456789, y: 362436069, z: 521288629, w: 88675123 };
			// TODO awful idea as it limits the possible initial states
			return { x: Math.floor(seed * UINT32_MAX), y: 0, z: 0, w: 0 };
		}

		function rngNext(state) {
			const t = state.x ^ (state.x << 11);
			const result = {
				x: state.y,
				y: state.z,
				z: state.w,
				w: wrapUInt32(state.w ^ ((state.w >>> 19) ^ t ^ (t >>> 8)))
			};
			console.assert((result.w >= 0) && (result.w < UINT32_MAX));
			return result;
		}

		const WIDTH = 1000;
		const HEIGHT = 800;
		const GRID_SIZE = 25;

		async function main() {
			const svg = document.getElementById('svg');
			svg.setAttribute('width', WIDTH);
			svg.setAttribute('height', HEIGHT);

			// https://www.freepik.com/free-vector/vintage-monochrome-mountains-set_7997411.htm
			const names = ['mountain1.svg', 'mountain2.svg', 'mountain3.svg'];
			const mountains = await Promise.all(names.map($ => loadSVG($)));

			// this would is the only user controlled number
			const seed = 0.3; // Math.random();

			const seedRandom = 0.7;
			const seedX = 0.9;
			const seedY = 0.8;

			const perlin = perlinCreate(seed, 10 + 2, 8 + 2);

			const gridBorderMin = 0.2;
			const gridBorderMax = 0.8;

			const w = Math.floor(WIDTH / GRID_SIZE);
			const h = Math.floor(HEIGHT / GRID_SIZE);
			// TOOD use gridForEach for init?
			const g = gridMake(w, h, (p) => {
				const xn = p.x / w;
				const yn = p.y / h;
				return {
					random: rnhNorm(seed, seedRandom, xn, yn), // used in many places
					x: (rnhMinMax(gridBorderMin, gridBorderMax, seed, seedX, xn, yn) + p.x) * GRID_SIZE,
					y: (rnhMinMax(gridBorderMin, gridBorderMax, seed, seedY, xn, yn) + p.y) * GRID_SIZE
				};
			});

			drawGrid(svg, GRID_SIZE);

			function selectBiome(p) {
				if (p.level > 1.4) return 'mountain';
				if (p.level > 1.0 && p.random < 0.02) return 'town';
				if (p.level > 0.8) return 'grass';
				return 'water';
			}

			const towns = [];
			// assign level & biomes
			gridForEach(g, 0, (grid, tile) => {
				const p = grid.data[tile.y][tile.x];
				let noise = perlinNoise(perlin, { x: p.x / 200, y: p.y / 200 });
				p.level = noise + 1.0; // 0 .. 2
				p.biome = selectBiome(p);
				if (p.biome === 'town') {
					towns.push({ x: p.x, y: p.y });
				}
			});


			// streets
			const SHOW_STREETS = true;
			if (SHOW_STREETS) {
				for (const from of towns) {
					const toList = towns.
						filter(to => (from.x != to.x) || (from.y != to.y)).
						map(to => ({ x: to.x, y: to.y, distance: distance(from, to) }));
					// only search the closest town
					if (toList.length > 0) {
						toList.sort((a, b) => a.distance > b.distance ? 1 : -1);
						svg.appendChild(createLine(from, toList[0], '#999'));
					}
				}
			}

			// biomes
			const BIOMES_COLORS = {
				'town': '#f0f',
				'water': '#00f',
				'grass': '#9f9',
				'mountain': '#999',
			};
			const SHOW_BIOMES = true;
			if (SHOW_BIOMES) {
				gridForEach(g, 0, (grid, tile) => {
					const p = grid.data[tile.y][tile.x];
					svg.appendChild(createCircle(p, BIOMES_COLORS[p.biome]));
				});
			}

			// mountains
			const items = [];
			gridForEach(g, 0, (grid, tile) => {
				const p = grid.data[tile.y][tile.x];
				if (p.biome === 'mountain') {
					// TODO maybe do not use the same seed for everything
					const m = mountains[Math.floor(p.random * mountains.length)];
					const node = m.cloneNode(true);
					const xScale = 1.1 + (p.random * 0.2);
					const yScale = 1.3 + (p.random * 0.2);
					const x = p.x;
					const y = p.y;
					items.push({ x: x, y: y, xs: xScale, ys: yScale, node });
				}
			});

			items.sort((a, b) => {
				return (a.y > b.y) ? 1 : -1;
			});

			const SHOW_ITEMS = true;
			if (SHOW_ITEMS) {
				for (const item of items) {
					const node = item.node;
					node.setAttribute('transform', 'translate(' + item.x + ' ' + item.y + ') scale(' + item.xs + ' ' + item.ys + ')')
					svg.appendChild(node);
				}
			}

			// draw coast
			gridForEach(g, 1, (grid, tile) => {
				const p = grid.data[tile.y][tile.x];
				const pl = grid.data[tile.y + 0][tile.x - 1];
				const pr = grid.data[tile.y + 0][tile.x + 1];
				const pt = grid.data[tile.y - 1][tile.x - 0];
				const pb = grid.data[tile.y + 1][tile.x + 0];
				const ptl = grid.data[tile.y - 1][tile.x - 1];
				const ptr = grid.data[tile.y - 1][tile.x + 1];
				const pbl = grid.data[tile.y + 1][tile.x - 1];
				const pbr = grid.data[tile.y + 1][tile.x + 1];
				let ps = [];

				// tr
				if (p.biome === 'water' && pt.biome == 'water' && ptr.biome == 'water' && pr.biome == 'grass') {
					ps.push(ptr);
				}
				if (p.biome === 'water' && pt.biome == 'water' && ptr.biome == 'grass' && pr.biome == 'grass') {
					ps.push(pt);
				}
				if (p.biome === 'water' && pt.biome == 'grass' && ptr.biome == 'grass' && pr.biome == 'water') {
					ps.push(pr);
				}
				if (p.biome === 'water' && pt.biome == 'grass' && ptr.biome == 'water' && pr.biome == 'water') {
					ps.push(ptr);
				}
				// br
				if (p.biome === 'water' && pb.biome == 'water' && pbr.biome == 'water' && pr.biome == 'grass') {
					ps.push(pbr);
				}
				if (p.biome === 'water' && pb.biome == 'water' && pbr.biome == 'grass' && pr.biome == 'grass') {
					ps.push(pb);
				}
				if (p.biome === 'water' && pb.biome == 'grass' && pbr.biome == 'water' && pr.biome == 'water') {
					ps.push(pbr);
				}
				if (p.biome === 'water' && pb.biome == 'grass' && pbr.biome == 'grass' && pr.biome == 'water') {
					ps.push(pr);
				}
				// bl
				if (p.biome === 'water' && pb.biome == 'water' && pbl.biome == 'water' && pl.biome == 'grass') {
					ps.push(pbl);
				}
				if (p.biome === 'water' && pb.biome == 'water' && pbl.biome == 'grass' && pl.biome == 'grass') {
					ps.push(pb);
				}
				if (p.biome === 'water' && pb.biome == 'grass' && pbl.biome == 'water' && pl.biome == 'water') {
					ps.push(pbl);
				}
				if (p.biome === 'water' && pb.biome == 'grass' && pbl.biome == 'grass' && pl.biome == 'water') {
					ps.push(pl);
				}
				// tl
				if (p.biome === 'water' && pt.biome == 'water' && ptl.biome == 'water' && pl.biome == 'grass') {
					ps.push(ptl);
				}
				if (p.biome === 'water' && pt.biome == 'water' && ptl.biome == 'grass' && pl.biome == 'grass') {
					ps.push(pt);
				}
				if (p.biome === 'water' && pt.biome == 'grass' && ptl.biome == 'water' && pl.biome == 'water') {
					ps.push(ptl);
				}
				if (p.biome === 'water' && pt.biome == 'grass' && ptl.biome == 'grass' && pl.biome == 'water') {
					ps.push(pl);
				}

				if (ps.length == 2) {
					svg.appendChild(createQuadraticBezier(middle(p, ps[0]), p, middle(p, ps[1]), '#00f'));
				} else if (ps.length == 4) {
					// other combinations 0213 may also work
					svg.appendChild(createQuadraticBezier(middle(p, ps[0]), p, middle(p, ps[1]), '#00f'));
					svg.appendChild(createQuadraticBezier(middle(p, ps[2]), p, middle(p, ps[3]), '#00f'));
				}
			});

		}

		document.addEventListener('DOMContentLoaded', main);
		//setTimeout(main, 400);
	</script>

<body>
	<object id="mountain1" type="image/svg+xml" data="mountain1.svg" style="display:none"></object>
	<svg id="svg"></svg>
</body>

</html>